/*
 * Fichero: 	practica2.c
 * Autor: 		Ricardo Panero
 * Fecha:		Noviembre de 2024
 * Descripción: SISTEMAS ELECTRÓNICOS. PRÁCTICA Nº 2.

   Objetivo:

	Utilizando el software Xilinx ISE 14.7 y Xilinx Software Development Kit (SDK) para programar el MicroBlaze,
	se pide implementar un sistema de control de luz y temperatura en una vivienda inteligente.

	Este sistema partirá de una serie de datos proporcionados por diversos sensores,
	como pueden ser la temperatura exterior e interior, la presencia de habitantes en la casa,
	la luz ambiental o el ruido exterior, y accionará diversos controladores que permitirían subir o bajar persianas,
	abrir o cerrar ventanas, y arrancar sistemas de calefacción o de aire acondicionado según se necesite,
	en base a unas normas generales.

	Por tanto, el objetivo del sistema es crear una vivienda inteligente monitorizada por los siguientes componentes y sensores:
	• 1 detector de presencia en la vivienda (ON – OFF).
	• 1 sensor de luz exterior (0 – 100%).
	• 2 sensores de temperatura ambiental, uno interior y otro exterior a la vivienda (0 – 60°C).
	• 1 detector de ruido exterior (0 – 120 dB).

	Y los sistemas que accionaremos serán los siguientes:
	• Luces de la casa, apagando o encendiendo las mismas (ON – OFF).
	• 1 motor para el control de la apertura y cierre de ventanas (0 – 100%).
	• 1 motor para controlar la subida y bajada de persianas (0 – 100%).
	• 1 control de calefacción, controlando la potencia de acción del mismo (0 – 100%).
	• 1 control de aire acondicionado, también con control de potencia de acción (0 – 100%).

	El sistema controlará tanto la activación de las luces de la vivienda como la subida y bajada de persianas para favorecer la entrada de luz
	en función de la cantidad de luz proveniente del exterior, dependiendo de si hay alguien o no en la vivienda.

	Además, controlará la temperatura, manteniendo ésta en un rango de entre 18 y 23°C.

	Para su correcto funcionamiento, el sistema deberá responder de la siguiente forma:
	C1. Si el detector de presencia no está activo supondremos que la vivienda está vacía,
		por tanto, se mantienen las luces apagadas, las persianas bajadas y las ventanas cerradas.
	C2. Si el detector de presencia está activo y el detector de luz muestra una luminosidad exterior entre el 75% y el 100%,
			se suben las persianas y se mantienen las luces apagadas.
		Si la luminosidad exterior se encuentra entre el 50% y el 75%,
			subir las persianas y encender las lámparas.
		En caso de que la luminosidad exterior sea inferior al 50%,
			bajar las persianas y encender la iluminación interior.
	C3. Cuando la temperatura exterior se encuentre entre 18 y 23°C,
			se deben abrir las ventanas de la vivienda para mantener ésta a la temperatura exterior, así como subir las persianas, independientemente de la luminosidad exterior.
		Para todo valor de temperatura exterior no perteneciente a este rango,
			mantener las ventanas cerradas y aplicar el siguiente criterio.
	C4. Si la temperatura interior se encuentra por debajo de los 18°C,
			se debe activar la calefacción para alcanzar dicha temperatura.
		Si esta temperatura es superior a 23°C,
			se debe activar el aire acondicionado con el objetivo de llegar a estos 23°C.
		En estos casos, las ventanas deberán estar cerradas, obviamente.
	C5. Considerando que las temperaturas en el exterior se encontrarán siempre en un rango de entre 0 y 60°C,
			se debe de activar la calefacción o el aire acondicionado según se ha descrito anteriormente.
			La potencia tanto del aire acondicionado como de la calefacción vendrá determinada por
			la diferencia entre la temperatura objetivo y la temperatura del interior de la vivienda,
			variando de forma lineal según varíe dicha diferencia,
			de forma que la potencia sea máxima cuando la diferencia de temperaturas sea máxima
			y nula cuando la temperatura del interior sea igual a la temperatura objetivo.
	C6. Siempre que el nivel de ruido exterior sea mayor de 40dB,
			mantener las ventanas cerradas independientemente de la temperatura exterior.


	Interacción del usuario con el sistema:
	U1. La placa de control de la FPGA nos permitirá modificar la temperatura exterior, el nivel de ruido, la cantidad de luz y la presencia en la vivienda.
		Q – A: Permitirán subir-bajar la temperatura exterior en saltos de 1°,
				partiendo de un valor inicial de 20°C (preprogramado al inicio del sistema),
				controlando los valores mínimos y máximos posibles.
		W – S: Permitirán subir-bajar la temperatura interior en saltos de 1°,
				partiendo de un valor inicial de 20°C (preprogramado al inicio del sistema),
				controlando los valores mínimos y máximos posibles.
		E – D: Permitirán subir-bajar el nivel de ruido en saltos de 1dB,
				partiendo de un valor inicial de 20dB (preprogramado al inicio del sistema),
				controlando los valores mínimos y máximos posibles.
		R – F: Permitirán subir-bajar el porcentaje de luz en saltos de 1%,
				partiendo de un valor inicial de 75% (preprogramado al inicio del sistema),
				controlando los valores mínimos y máximos posibles.
		P: 	  Permitirá controlar la activación / desactivación del detector de presencia (ON – OFF),
				partiendo de un valor inicial de OFF.

	U2. En la pantalla se mostrará toda la información del sistema, que incluye
	 	 el valor de todos los sensores, así como los sistemas que accionamos para el control de la vivienda, con sus unidades respectivas.
		 Cada vez que el usuario modifique algún valor del sensor,
		 	 o bien debido a un cambio en el sistema por tiempo
 	 	 	 o por autoincremento/autodecremento de la temperatura,
		 	 se recalcularán los valores necesarios y se volverá a imprimir toda la información en pantalla.
		 En el caso de las persianas y ventanas, será necesario mostrar tanto si están abiertas o cerradas,
		 	 así como el % de funcionamiento del motor si se está moviendo;
		 	 en este último caso, indicar también si la ventana o persiana estaría abriéndose o cerrándose.
		 Inicialmente se encontrará todo cerrado.

	Restricciones:
		R1. Para suponer un cambio de estado en el sensor de presencia en la vivienda,
			éste deberá estar al menos 5 segundos consecutivos en un nuevo estado (ON u OFF).
			Si vuelve a cambiar al estado previo antes de 5 segundos
				no se debe realizar ninguna acción,
				y el tiempo de cuenta de 5 segundos se resetea.
		R2. Todo el control y almacenamiento de los datos de los sensores se realizará dentro del propio MicroBlaze:
			detección de presencia, sensor de luz exterior, sensor de temperatura exterior e interior, y detector de ruido exterior.
		R3. También se controlará en el interior del MicroBlaze la acción sobre los motores de las persianas y ventanas para abrirlas y cerrarlas,
			generando un cambio progresivo en los mismos.
			La idea es que el proceso de abrir o cerrar persianas o ventanas se complete en 10 segundos,
			comenzando y terminando con movimientos lentos del motor (poca potencia), y estando al 100% de potencia a mitad del recorrido.
			Igualmente, acompañar estos valores de % de movimiento del motor con indicaciones
				si la ventana se está “CERRANDO” o “ABRIENDO”,
				y en el caso de las persianas si están “SUBIENDO” o “BAJANDO”.
			Al llegar al final de su recorrido se mostrará por pantalla su situación final.
 R4. Se controlará en la parte de la FPGA el cálculo de la potencia correspondiente a los motores de la calefacción y el aire acondicionado,
		proporcionándole el MicroBlaze los datos necesarios, a través de uno o varios GPO de salida,
		para calcular la potencia instantánea del motor en cada caso,
		acompañando los datos con una señal de sincronismo necesaria (“datos_nuevos”)
		que también saldrá por un GPO de salida.
	El valor del % de potencia del motor, una vez calculado, se leerá por un puerto GPI de entrada al MicroBlaze
		cuando el módulo externo así lo indique,
		utilizando para ello una interrupción externa (INTC).
 R5. El alumno será responsable de crear las funciones lineales de control de la potencia de la calefacción y del aire acondicionado para que cumplan con los requisitos establecidos.
		Estos cálculos, como se ha indicado, se realizarán en un único módulo en la parte de la FPGA,
		diseñando el circuito necesario para aceptar los datos desde el MicroBlaze,
		activando el cálculo,
		y ofreciendo los resultados de nuevo al MicroBlaze.
		R6. Igualmente, el alumno deberá implementar en el MicroBlaze un sistema lógico de “autoincrementos” o “autodecrementos”
			cada cierto tiempo en la temperatura interior de la vivienda en caso de abrirse las ventanas y persianas para adecuar la temperatura interna a la externa
			o cuando se activa la calefacción o el aire acondicionado,
			llegando a la temperatura objetivo (18°C en el caso de ser necesario calentar la vivienda y 23°C en el caso de tener que enfriarla).

 */

#include "practica2.h"

//- Variables globales
		u8 SemActuadores = 0;  	// Semáforno para determinar cuando se producen cambios en los actuadores (consecuencia de los sensoree)
		u8 SemSensores = 0;  	// Semáforno para determinar cuando se producen cambios en los sensores (derivados de pulsaciones de teclas y/o botones)
		u8 SemFpgaPot = 0;  	// Semáforno para determinar cuando se recibe el cálculo de la potencia
		u8 SemTm100ms = 0;  	// Semáforno para indicar que saltó la interrupción cada 100 ms
		u8 ModoSensores = 0;	// Número de sensor activo (0=PRENSENCIA, 1=LUZ...)
		u8 ModoActuadores = 0;  // Número de actuador activo
		char UltTecla = '\0';   // última tecla pulsada
		char PotCli = 0; 		// potencia de climatización devuelta por la FPGA positiva=>calefacción, negativa=>Aire


//- ControlarActuadores
    void ControlarActuadores(st_Sensores *pSen, st_Actuadores *pAct) {
    	/*
        El sistema controlará tanto la activación de las luces de la vivienda como la subida y bajada de persianas
        para favorecer la entrada de luz en función de la cantidad de luz proveniente del exterior,
        dependiendo de si hay alguien o no en la vivienda.

        Además, controlará la temperatura, manteniendo ésta en un rango de entre 18 y 23°C.

        Para su correcto funcionamiento, el sistema deberá responder de la siguiente forma:
        C1. Si el detector de presencia no está activo supondremos que la vivienda está vacía, por tanto,
            se mantienen las luces apagadas, las persianas bajadas y las ventanas cerradas.
        C2. Si el detector de presencia está activo y el detector de luz muestra una luminosidad exterior entre el 75% y el 100%,
            se suben las persianas y se mantienen las luces apagadas.
            Si la luminosidad exterior se encuentra entre el 50% y el 75%,
            subir las persianas y encender las lámparas.
            En caso de que la luminosidad exterior sea inferior al 50%,
            bajar las persianas y encender la iluminación interior.
        C3. Cuando la temperatura exterior se encuentre entre 18 y 23°C,
            se deben abrir las ventanas de la vivienda para mantener ésta a la temperatura exterior,
            así como subir las persianas, independientemente de la luminosidad exterior.
            Para todo valor de temperatura exterior no perteneciente a este rango,
            mantener las ventanas cerradas y aplicar el siguiente criterio.
        C4. Si la temperatura interior se encuentra por debajo de los 18°C,
            se debe activar la calefacción para alcanzar dicha temperatura.
            Si esta temperatura es superior a 23°C,
            se debe activar el aire acondicionado con el objetivo de llegar a estos 23°C.
            En estos casos, las ventanas deberán estar cerradas, obviamente.
        C5. Considerando que las temperaturas en el exterior se encontrarán siempre en un rango de entre 0 y 60°C,
            se debe de activar la calefacción o el aire acondicionado según se ha descrito anteriormente.
            La potencia tanto del aire acondicionado como de la calefacción vendrá determinada por
            la diferencia entre la temperatura objetivo y la temperatura del interior de la vivienda,
            variando de forma lineal según varíe dicha diferencia, de forma que la potencia
            sea máxima cuando la diferencia de temperaturas sea máxima y
            nula cuando la temperatura del interior sea igual a la temperatura objetivo.
        C6. Siempre que el nivel de ruido exterior sea mayor de 40dB,
            mantener las ventanas cerradas independientemente de la temperatura exterior.
    	 */

        // C1 Si el detector de presencia no está activo supondremos que la vivienda está vacía,
        //    por tanto, se mantienen las luces apagadas, las persianas bajadas y las ventanas cerradas.
    	pAct->luz.e_sig = pAct->luz.e_act;
    	pAct->ven.e_sig = pAct->ven.e_act;
    	pAct->per.e_sig = pAct->per.e_act;
    	pAct->cal.e_sig = pAct->cal.e_act;
    	pAct->air.e_sig = pAct->air.e_act;

        if (pSen->Prese==AUSENTE) {
        	pAct->luz.e_sig = ST_APAGAR;
        	pAct->ven.e_sig = ST_CERRADAS;
        	pAct->per.e_sig = ST_BAJADAS;
        	pAct->cal.e_sig = ST_APAGAR;
        	pAct->air.e_sig = ST_APAGAR;
        }


        // C2a Si el detector de presencia está activo
        //     y el detector de luz muestra una luminosidad exterior entre el 75% y el 100%
        //     se suben las persianas y se mantienen las luces apagadas.
        if (pSen->Prese==PRESENTE && pSen->LuzEx>=75 && pSen->LuzEx<=100) {
        	pAct->luz.e_sig = ST_APAGAR;
        	pAct->per.e_sig = ST_SUBIDAS;
        }

        // C2b Si la luminosidad exterior se encuentra entre el 50% y el 75%,
        //     subir las persianas y encender las lámparas.
        else if (pSen->Prese==PRESENTE && pSen->LuzEx>=50 && pSen->LuzEx<75) {
        	pAct->luz.e_sig = ST_ENCENDER;
        	pAct->per.e_sig = ST_SUBIDAS;
		}

        // C2c En caso de que la luminosidad exterior sea inferior al 50%,
        //     bajar las persianas y encender la iluminación interior.
        else if (pSen->Prese==PRESENTE) {  //  && pSen->LuzEx<50) {
        	pAct->luz.e_sig = ST_ENCENDER;
        	pAct->per.e_sig = ST_BAJADAS;
        }

        // C3a Cuando la temperatura exterior se encuentre entre 18 y 23°C,
        //     se deben abrir las ventanas de la vivienda para mantener ésta a la temperatura exterior,
        //     así como subir las persianas, independientemente de la luminosidad exterior.
        if (pSen->Prese==PRESENTE && pSen->TemEx>=OBJ_CAL && pSen->TemEx<=OBJ_AIR) {
        	pAct->ven.e_sig = ST_ABIERTAS;
        	pAct->per.e_sig = ST_SUBIDAS;
        	pAct->cal.e_sig = ST_APAGAR;
        	pAct->air.e_sig = ST_APAGAR;
        }

        // C3b Para todo valor de temperatura exterior no perteneciente a este rango,
        //     mantener las ventanas cerradas y aplicar el siguiente criterio.
        // C4a Si la temperatura interior se encuentra por debajo de los 18°C,
        //     se debe activar la calefacción para alcanzar dicha temperatura.
        // C4b Si esta temperatura es superior a 23°C,
        //     se debe activar el aire acondicionado con el objetivo de llegar a estos 23°C.
        //     En estos casos, las ventanas deberán estar cerradas, obviamente.
    	// C5. Considerando que las temperaturas en el exterior se encontrarán siempre en un rango de entre 0 y 60°C,
        //     se debe de activar la calefacción o el aire acondicionado según se ha descrito anteriormente.
        //     La potencia tanto del aire acondicionado como de la calefacción vendrá determinada por
        //     la diferencia entre la temperatura objetivo y la temperatura del interior de la vivienda,
        //     variando de forma lineal según varíe dicha diferencia,
        //     de forma que la potencia sea máxima cuando la diferencia de temperaturas sea máxima
        //     y nula cuando la temperatura del interior sea igual a la temperatura objetivo.
        else if (pSen->Prese==PRESENTE && pSen->TemIn<OBJ_CAL) {
        	pAct->ven.e_sig = ST_CERRADAS;
        	pAct->cal.e_sig = ST_CALENTAR;
        	pAct->air.e_sig = ST_APAGAR;
        }

        else if (pSen->Prese==PRESENTE) { // && pSen->TemIn > OBJ_AIR
        	pAct->ven.e_sig = ST_CERRADAS;
        	pAct->cal.e_sig = ST_APAGAR;
        	pAct->air.e_sig = ST_ENFRIAR;
        }

        //- Cierre de la ventana cuando hay ruido; si hace buen tiempo, encender el aire o la calefacción si es preciso porque las entanas están cerradas
			// C6. Siempre que el nivel de ruido exterior sea mayor de 40dB,
			//     mantener las ventanas cerradas independientemente de la temperatura exterior.
			if (pSen->Ruido>40) {
				pAct->ven.e_sig = ST_CERRADAS;
				if (pSen->TemIn<OBJ_CAL) {
		        	pAct->cal.e_sig = ST_CALENTAR;
		        	pAct->air.e_sig = ST_APAGAR;
				} else if (pSen->TemIn>OBJ_AIR) {
		        	pAct->cal.e_sig = ST_APAGAR;
		        	pAct->air.e_sig = ST_ENFRIAR;
				}
			}

		//- encendido o apagado instantáneo de luces
			if (pAct->luz.e_act != pAct->luz.e_sig) {
				SemActuadores = 1;
				pAct->luz.e_act = pAct->luz.e_sig;
			}

		//- apertura o cierre gradual de ventanas
			if (pAct->ven.e_sig==ST_ABIERTAS && pAct->ven.e_act!=ST_ABIERTAS && pAct->ven.e_act!=ST_ABRIENDO) {
				SemActuadores = 1;
				pAct->ven.e_act = ST_ABRIENDO;
			} else if (pAct->ven.e_sig==ST_CERRADAS && pAct->ven.e_act!=ST_CERRADAS && pAct->ven.e_act!=ST_CERRANDO) {
				SemActuadores = 1;
				pAct->ven.e_act = ST_CERRANDO;
			}

		//- apertura o cierre gradual de ventanas
			if (pAct->per.e_sig==ST_SUBIDAS && pAct->per.e_act!=ST_SUBIDAS && pAct->per.e_act!=ST_SUBIENDO) {
				SemActuadores = 1;
				pAct->per.e_act = ST_SUBIENDO;
			} else if (pAct->per.e_sig==ST_BAJADAS && pAct->per.e_act!=ST_BAJADAS && pAct->per.e_act!=ST_BAJANDO) {
				SemActuadores = 1;
				pAct->per.e_act = ST_BAJANDO;
			}

		//- encendido o apagado de la calefacción
			if (pAct->cal.e_act != pAct->cal.e_sig) {
				SemActuadores = 1;
				pAct->cal.e_act = pAct->cal.e_sig;
			}

		//- encendido o apagado del aire acondicionado
			if (pAct->air.e_act != pAct->air.e_sig) {
				SemActuadores = 1;
				pAct->air.e_act = pAct->air.e_sig;
			}

    } // ControlarActuadores

    /*
 * 			if  {
				XIOModule_DiscreteWrite(&iomodule, GPO_TEMPERATURAS, MASK_0_CAL | (pSen->TemIn)); // dato
				XIOModule_DiscreteWrite(&iomodule, GPO_TEMPERATURAS, MASK_1_CAL | (pSen->TemIn)); // pulso
				XIOModule_DiscreteWrite(&iomodule, GPO_TEMPERATURAS, MASK_0_CAL | (pSen->TemIn)); // dato
				MascaraGpiTem = MASK_1_CAL | (pSen->TemIn);
			} else { // if (pSen->TemIn > OBJ_AIR) {
				XIOModule_DiscreteWrite(&iomodule, GPO_TEMPERATURAS, MASK_0_AIR | (pSen->TemIn)); // dato
				XIOModule_DiscreteWrite(&iomodule, GPO_TEMPERATURAS, MASK_1_AIR | (pSen->TemIn)); // pulso
				XIOModule_DiscreteWrite(&iomodule, GPO_TEMPERATURAS, MASK_0_AIR | (pSen->TemIn)); // dato
				MascaraGpiTem = MASK_1_AIR | (pSen->TemIn);
            }
        }

        if (PotCli == 0) {
            pAct->ptCal = APAGADO;      	// apagar la calefacción para optimizar energía
            pAct->ptAir = APAGADO;      	// apagar el aire acondicionado para optimizar energía
        } else if (PotCli > 0) {
            pAct->ptCal = PotCli;      		// encender la calefacción según la potencia calculada
            pAct->ptAir = APAGADO;      	// apagar el aire acondicionado para optimizar energía
        } else {
            pAct->ptCal = APAGADO;      	// apagar la calefacción para optimizar energía
            pAct->ptAir = (u8)(-PotCli);   // encender el aire cambiando el signo a la potencia calculada
        }

        //- Ajustar el estado de las ventanas según el nivel recorrido
        if (pAct->stVen==ST_ABRIENDO && pAct->grVen==MAX_APERTURA) {
        	pAct->stVen = ST_ABIERTAS;
        	pAct->mtVen = APAGADO;
        }

        else if (pAct->stVen==ST_CERRANDO && pAct->grVen==MIN_APERTURA) {
        	pAct->stVen = ST_CERRADAS;
        	pAct->mtVen = APAGADO;
        }

        //- Ajustar el estado de las persianas según el nivel recorrido
		if (pAct->stPer==ST_ABRIENDO && pAct->grPer==MAX_APERTURA) {
			pAct->stPer = ST_ABIERTAS;
			pAct->mtPer = APAGADO;
		}

		else if (pAct->stPer==ST_CERRANDO && pAct->grPer==MIN_APERTURA) {
			pAct->stPer = ST_CERRADAS;
			pAct->mtPer = APAGADO;
		}



 *
 * */

//- SimularSensores (requisito U1)
    /*
    U1. La placa de control de la FPGA nos permitirá modificar la temperatura exterior, el nivel de ruido, la cantidad de luz y la presencia en la vivienda.
    Q – A: Permitirán subir-bajar la temperatura exterior en saltos de 1°, partiendo de un valor inicial de 20°C (preprogramado al inicio del sistema), controlando los valores mínimos y máximos posibles.
    W – S: Permitirán subir-bajar la temperatura interior en saltos de 1°, partiendo de un valor inicial de 20°C (preprogramado al inicio del sistema), controlando los valores mínimos y máximos posibles.
    E – D: Permitirán subir-bajar el nivel de ruido en saltos de 1dB, partiendo de un valor inicial de 20dB (preprogramado al inicio del sistema), controlando los valores mínimos y máximos posibles.
    R – F: Permitirán subir-bajar el porcentaje de luz en saltos de 1%, partiendo de un valor inicial de 75% (preprogramado al inicio del sistema), controlando los valores mínimos y máximos posibles.
    P: Permitirá controlar la activación / desactivación del detector de presencia (ON – OFF), partiendo de un valor inicial de OFF.
    */

    //- Actualiza el valor de un actuador controlando en función de la tecla pulsada y los límites
    u8 ActualizarValor(char tecla, char subir, char bajar, u8 valorAct, u8 LimInf, u8 LimSup) {
    	// comprobar si la tecla es igual a la de subida en mayúsculas o en minúsculas (+0x20)
        if ((tecla == subir) && (valorAct < LimSup)) {
            return valorAct + 1;
        }
        else if ((tecla == bajar) && (valorAct > LimInf)) {
            return valorAct - 1;
        }
        else
            return valorAct;
    } // ActualizarValor


    void SimularSensores(XIOModule *pIomodule, st_Sensores *pSen) {

    	//- Si no se pulsaron botones, intentar leer una tecla
    		if (UltTecla == '\0') {
                //- Intentar leer del puerto serie
                	static char rx_buf[2];
                	static u32 numRecv;
                	numRecv = XIOModule_Recv(pIomodule, (u8 *)rx_buf, 1);

                //- Si hay datos, actualizar la última tecla pulsada y convertirla a mayúsuculas
					if (numRecv != 0)
						UltTecla = rx_buf[0];
					if (UltTecla >='a')
						UltTecla -= 0x20;
    		}

    	//- Si no ha cambiado ningún sensor, salir sin cambios. En caso contrario activar el semáforo de sensores
    		if (UltTecla == '\0') {
    			return;
    		}
    		SemSensores = 1;

		//- Gestión de los botones/teclas de dirección
            if ((UltTecla==TECLA_IZQ) || (UltTecla==TECLA_DER) || (UltTecla==TECLA_ARR) || (UltTecla==TECLA_ABA)) {
				//- Determinar si estamos en modo sensores o actuadores dependiendo del primer switch
            		u8 data_sw, modo_sensores;
					data_sw = XIOModule_DiscreteRead(pIomodule, GPI_SWITCHES);
					modo_sensores = (data_sw & 0x80);

            	//- Gestionar el cambio del sensor/actuador activo (teclas o botones izquierda y derecha) y actualizar los leds
					if ((UltTecla == TECLA_IZQ) || (UltTecla == TECLA_DER)) {

						//- modo sensores, actualizamos el modo según la tecla y ajustamos los leds
							if (modo_sensores) {
								if (UltTecla==TECLA_IZQ)
									ModoSensores = (ModoSensores==4) ? 0 : ModoSensores + 1;
								else // tecla izquierda
									ModoSensores = (ModoSensores==0) ? 4 : ModoSensores - 1;
	//!!!							XIOModule_DiscreteWrite(pIomodule, GPO_LEDS, modo_sensores | (0x1 << ModoSensores));
							}

						//- modo actuadores, actualizamos el modo según la tecla y ajustamos los leds
							else {
								if (UltTecla==TECLA_IZQ)
									ModoActuadores = (ModoActuadores==4) ? 0 : ModoActuadores + 1;
								else // tecla izquierda
									ModoActuadores = (ModoActuadores==0) ? 4 : ModoActuadores - 1;
	//!!!								XIOModule_DiscreteWrite(pIomodule, GPO_LEDS, modo_sensores | (0x1 << ModoActuadores));
							}
					}

				//- Gestionar el incremento del sensor activo (tecla/botón arriba); los actuadores no se pueden actualizar
					if ((UltTecla == TECLA_ARR) && ModoSensores) {
						switch (ModoSensores) {
							case 0: UltTecla = 'P'; break; // cambiar presencia
							case 1: UltTecla = 'R'; break; // subir luz exterior
							case 2: UltTecla = 'Q'; break; // subir temperatura exterior
							case 3: UltTecla = 'W'; break; // subir temeratura interior
							case 4: UltTecla = 'E'; break; // subir nivel de ruido
						}
					}

				//- Gestionar el decremento o del sensor activo (tecla/botón abajo); los actuadores no se pueden actualizar
					else if ((UltTecla == TECLA_ABA) && ModoSensores) {
						switch (ModoSensores) {
							case 0: UltTecla = 'P'; break; // cambiar presencia
							case 1: UltTecla = 'F'; break; // bajar luz exterior
							case 2: UltTecla = 'A'; break; // bajar temperatura exterior
							case 3: UltTecla = 'S'; break; // bajar temeratura interior
							case 4: UltTecla = 'D'; break; // bajar nivel de ruido
						}
					}
            }

			//- Actualizamos sensores según la tecla pulsada
				pSen->TemEx = ActualizarValor(UltTecla, 'Q', 'A', pSen->TemEx, MIN_TEMP, MAX_TEMP);
				pSen->TemIn = ActualizarValor(UltTecla, 'W', 'S', pSen->TemIn, MIN_TEMP, MAX_TEMP);
				pSen->Ruido = ActualizarValor(UltTecla, 'E', 'D', pSen->Ruido, MIN_RUIDO, MAX_RUIDO);
				pSen->LuzEx = ActualizarValor(UltTecla, 'R', 'F', pSen->LuzEx, MIN_LUZEX, MAX_LUZEX);

				// R1. Para suponer un cambio de estado en el sensor de presencia en la vivienda,
				//     éste deberá estar al menos 5 segundos consecutivos en un nuevo estado (ON u OFF).
				//     Si vuelve a cambiar al estado previo antes de 5 segundos
				//  	no se debe realizar ninguna acción,
				//		y el tiempo de cuenta de 5 segundos se resetea.
				if (UltTecla == 'P') {
					pSen->PSigu = (pSen->PSigu==PRESENTE) ? AUSENTE : PRESENTE; // siguiente estado de presencia
					pSen->PTime = 0; // inicialización del timer que se actualiza cada segundo
				}

			//- Reseteamos la última tecla
				UltTecla = '\0';


    } // SimularSensores


    //- ActualizarPantalla (requisito U2)
        /*
             U2. En la pantalla se mostrará toda la información del sistema,
             que incluye el valor de todos los sensores,
             así como los sistemas que accionamos para el control de la vivienda, con sus unidades respectivas.
             Cada vez que el usuario modifique algún valor del sensor, o bien debido a un cambio en el sistema
             por tiempo o por autoincremento/autodecremento de la temperatura,
             se recalcularán los valores necesarios y se volverá a imprimir toda la información en pantalla.
             En el caso de las persianas y ventanas, será necesario mostrar tanto si están abiertas o cerradas,
             así como el % de funcionamiento del motor si se está moviendo;
             en este último caso, indicar también si la ventana o persiana estaría abriéndose o cerrándose.
             Inicialmente se encontrará todo cerrado.
         */

        void ActualizarPantalla(XIOModule *pIomodule, st_Sensores *pSen, st_Actuadores *pAct) {
    		//- Leer el estado de los switches
    			u8 data_sw;
    			data_sw = XIOModule_DiscreteRead(pIomodule, GPI_SWITCHES);

    		//- refresca los leds y el display de 7 segmentos sengún el modo y los valores de sensores/actuadores
    			u8 data_raw;
    			if (data_sw & 0x80) {
    				XIOModule_DiscreteWrite(pIomodule, GPO_LEDS,  0x80 | (0x1 << ModoSensores));
    				switch (ModoSensores) {
    					case 0:  data_raw=pSen->Prese; break;
    					case 1:  data_raw=pSen->LuzEx; break;
    					case 2:  data_raw=pSen->TemEx; break;
    					case 3:  data_raw=pSen->TemIn; break;
    					case 4:  data_raw=pSen->Ruido; break;
    				}
    			} else {
    				XIOModule_DiscreteWrite(pIomodule, GPO_LEDS,  0x00 | (0x1 << ModoActuadores));
    				switch (ModoActuadores) {
    					case 0:  data_raw=pAct->luz.e_act; break;
    					case 1:  data_raw=pAct->ven.poten; break;
    					case 2:  data_raw=pAct->per.poten; break;
    					case 3:  data_raw=pAct->cal.poten; break;
    					case 4:  data_raw=pAct->air.poten; break;
    				}
    			}
    		//- actualización del display 7 segmentos
    			u16 data_bcd;
    			u16 dig_uni=0, dig_dec=0, dig_cen=0, dig_mil=0;
    			dig_uni = data_raw % 10;
    			dig_dec = (((data_raw-dig_uni)/10)%10) << 4;
    			dig_cen = (data_raw < 100) ? 0x0000 : 0x0100; // centenas o no dependiendo del valor < 100
    			dig_mil = (data_sw && 0x80) ? 0xD000 : 0xA000; // D=Datos de sensores y A=Actuadores
    			data_bcd = dig_mil |dig_cen | dig_dec | dig_uni;
    			XIOModule_DiscreteWrite(pIomodule, GPO_BCDS, data_bcd);

            // símbolo para grados centígrados en ASCII
                #define GRADOS 176

            //- decodificación de constantes simbólicas
                static const char *decodePrese[] = {"Ausente", "Presente"};

            //- Estado de sensores
                xil_printf("\033[H");
                xil_printf("\n\r\n\rESTADO DE SENSORES: ");
                xil_printf("\n\r   Presencia P:              %s        ", decodePrese[pSen->Prese]);
                xil_printf("\n\r   Luz exterior R/F:         %d %%     ", pSen->LuzEx);
                xil_printf("\n\r   Temperatura exterior Q/A: %d %cC    ", pSen->TemEx, GRADOS);
                xil_printf("\n\r   Temperatura interior W/S: %d %cC    ", pSen->TemIn, GRADOS);
                xil_printf("\n\r   Ruido E/D:                %d dB     ", pSen->Ruido);

            //- Estado de actuadores
                xil_printf("\n\r\n\rESTADO DE ACTUADORES: ");

                //- Luces
                    xil_printf("\n\r   Luces:    %s                    ", decod_estado[pAct->luz.e_act]);

                //- Ventanas y persianas; indicar el estado y la potencia del motor o sólo el estado si el motor está apagado
                    /*
                        R3c Igualmente, acompañar estos valores de % de movimiento del motor con indicaciones
                        si la ventana se está “CERRANDO” o “ABRIENDO”,
                        y en el caso de las persianas si están “SUBIENDO” o “BAJANDO”.
                        Al llegar al final de su recorrido se mostrará por pantalla su situación final.
                    */
                    if (pAct->ven.e_act==ST_ABIERTAS || pAct->ven.e_act==ST_CERRADAS)
                        xil_printf("\n\r   Ventanas:    %s                    ", decod_estado[pAct->ven.e_act]);
                    else
                        xil_printf("\n\r   Ventanas:    %s - motor al %d %% %d  ", decod_estado[pAct->ven.e_act], pAct->ven.poten, pAct->ven.grado);

                    if (pAct->per.e_act==ST_SUBIDAS || pAct->per.e_act==ST_BAJADAS)
                        xil_printf("\n\r   Persianas:   %s                    ", decod_estado[pAct->per.e_act]);
                    else
                        xil_printf("\n\r   Persianas:   %s - motor al %d %%  %d ", decod_estado[pAct->per.e_act], pAct->per.poten, pAct->per.grado);

                //- Calefacción y aire
                    xil_printf("\n\r   Calefacción:  %d %%          ", pAct->cal.poten);
                    xil_printf("\n\r   Aire acondicionado:  %d %%   ", pAct->cal.poten);

            //- Volcar la pantalla
                xil_printf("\t");

            return;
        }

//---------------------------------------------------------------------

/*

* helloworld.c: simple test application
 */


//- Manejador respuesta del cálculo de potencia
	void Manejador_Potencia (void* ref) {
		//- Leemos la potencia calculada en el GPI y la tratamos como int de 8
		SemFpgaPot = 1;
	}

//- Manejador botón derecho: avanzar ciclicamente el modo de sensores/actuadores 1=Prese/ctLuz, 2=LuzEx/mtVen, 3=TemIn/mtPer, 4=TemEx/ptCal 5=Ruido/ptAir
	void Manejador_BotonDer (void* ref) {
		//- Simulamos que hemos pulsado la tecla del botón derecho (dígito 6)
			UltTecla = TECLA_DER;
	}

//- Manejador botón izquierdo: retroceder ciclicamente el modo de sensores/actuadores 1=Prese/ctLuz, 2=LuzEx/mtVen, 3=TemIn/mtPer, 4=TemEx/ptCal 5=Ruido/ptAir
	void Manejador_BotonIzq (void* ref) {
		//- Simulamos que hemos pulsado la tecla del botón izquierdo (dígito 4)
			UltTecla = TECLA_IZQ;
	}

//- Manejador botón arriba: en modo sensor, aumentar el sensor elegido
	void Manejador_BotonArr (void* ref) {
		//- Simulamos que hemos pulsado la tecla del botón arriba (dígito 8)
			UltTecla = TECLA_ARR;
	}

//- Manejador botón arriba: en modo sensor, aumentar el sensor elegido
	void Manejador_BotonAba (void* ref) {
		//- Simulamos que hemos pulsado la tecla del botón abajo (dígito 2)
			UltTecla = TECLA_ABA;
	}

//- Manejador de interrupciones del temporizador FIT1, programado a 1 segundo
	void Manejador_Tic_segundos (void* ref)	{
		SemTm100ms = 1;
	}
//-
//- Función de actualización por tiempo, se activa cada segundo
	void ActualizarPorTiemo(st_Sensores *pSen, st_Actuadores *pAct) {

		//- actualización por tiempo del sensor de presencia
			if (pSen->Prese != pSen->PSigu) {
				pSen->PTime++; // aumentamos un tic el contador de espera de 5 segundos para cambiar de estado
			}

		//- actualización de motores de ventanas
			// R3b La idea es que el proceso de abrir o cerrar persianas o ventanas se complete en 10 segundos,
			//     comenzando y terminando con movimientos lentos del motor (poca potencia),
			//     y estando al 100% de potencia a mitad del recorrido.

			if (pAct->ven.e_act == ST_ABRIENDO) {
				if (pAct->ven.grado<MAX_APERTURA) {
					pAct->ven.grado++;
					pAct->ven.poten += (pAct->ven.grado<MED_APERTURA) ? 2 : -2;
				}
				else {
					pAct->ven.e_act = ST_ABIERTAS;
					pAct->ven.poten = 0;
				}

			}  else if (pAct->ven_e_act == ST_CERRANDO) {
				if (pAct->ven.grado>MIN_APERTURA) {
					pAct->ven.grado--;
					pAct->ven.poten += (pAct->ven.grado>MED_APERTURA) ? 2 : -2;
				}
				else {
					pAct.ven.e_act = ST_CERRADAS;
					pAct->ven.poten = 0;
				}
			}

			if (pAct->stPer == ST_ABRIENDO) {
				if (pAct->grPer<MAX_APERTURA)
					pAct->grPer++;
				else
					pAct->stPer = ST_ABIERTAS;
			}  else if (pAct->stPer == ST_CERRANDO) {
				if (pAct->grPer>MIN_APERTURA)
					pAct->grPer--;
				else
					pAct->stPer = ST_CERRADAS;
			}

		//- Actualizar la potencia en función del grado de apertura
			pAct->mtVen = PotenciaApertura[pAct->grVen];
			pAct->mtPer = PotenciaApertura[pAct->grPer];

		//- Cambios en los sensores por tiempo
			// R6. Igualmente, el alumno deberá implementar en el MicroBlaze un sistema lógico de “autoincrementos” o “autodecrementos”
			//     cada cierto tiempo en la temperatura interior de la vivienda en caso de abrirse las ventanas y persianas para adecuar la temperatura interna a la externa
		    //     o cuando se activa la calefacción o el aire acondicionado,
			//     llegando a la temperatura objetivo (18°C en el caso de ser necesario calentar la vivienda y 23°C en el caso de tener que enfriarla).
				static u32 segundos_desde_ult_incremento = 0;
				if (segundos_desde_ult_incremento < 10) {
					segundos_desde_ult_incremento++;
				} else {
					segundos_desde_ult_incremento = 0;
					if (pSen->TemIn < OBJ_CAL) {
						if (pSen->TemEx>OBJ_CAL && pAct->stVen == ST_ABIERTAS) {// pendiente tener en cuenta la diferencia de temperaturas
							pSen->TemIn++;
						}
						if (pAct->ptCal>0) { // pendiente tener en cuenta la potencia de la calefacción
							pSen->TemIn++;
						}
					} else if (pSen->TemIn > OBJ_AIR) {
						if (pSen->TemEx<OBJ_AIR && pAct->stVen == ST_ABIERTAS) { // pendiente tener en cuenta la diferencia de temperaturas
							pSen->TemIn--;
						}
						if (pAct->ptAir>0) { // pendiente tener en cuenta la potencia del aire acondicionado
							pSen->TemIn--;
						}
					}
				} // else

		        //- Anque no se haya pulsado ninguna tecla, comprobar si pasaron 5 segundos desde el cambio del sensor de presencia
		            if (pSen->Prese!=pSen->PSigu && pSen->PTime >= 5)
		            {
		            	SemCambios = 1;
		            	pSen->Prese = pSen->PSigu;
		            	pSen->PTime = 0;
		            }

	} // ActualizarPorTiemo

//- Inicializar
	void Inicializar(XIOModule *piomodule, st_Sensores *pSen, st_Actuadores *pAct ) {
		//- Inicializa el micro
	        init_platform();

	    //- Inicializa el módulo de GPI, GPO y la UART para obtener la dirección base:
	        u32 res; // resultado de llamadas a Xilinx
	    	res = XIOModule_Initialize(piomodule, XPAR_IOMODULE_0_DEVICE_ID);
	    	res = XIOModule_Start(piomodule);
	    	res = XIOModule_CfgInitialize(piomodule, NULL, 1);

	    //- Inicializamos el manejador de interrupciones
	    	microblaze_register_handler(XIOModule_DeviceInterruptHandler, XPAR_IOMODULE_0_DEVICE_ID);

	    //- Registramos y activamos las interrupciones del temporizador para FIT1 (temporizador a 1 segundo)
	    	XIOModule_Connect(piomodule, XIN_IOMODULE_FIT_1_INTERRUPT_INTR, Manejador_Tic_segundos, NULL);
	    	XIOModule_Enable(piomodule, XIN_IOMODULE_FIT_1_INTERRUPT_INTR);

	    //- Registramos y activamos las interrupciones botón derecho e izquierdo (Interrupciones externa 0 y 1)
	    	XIOModule_Connect(piomodule, INTERRUPCION_BOTON_DER, Manejador_BotonDer, NULL);
	    	XIOModule_Connect(piomodule, INTERRUPCION_BOTON_IZQ, Manejador_BotonIzq, NULL);
	    	XIOModule_Connect(piomodule, INTERRUPCION_BOTON_ARR, Manejador_BotonArr, NULL);
	    	XIOModule_Connect(piomodule, INTERRUPCION_BOTON_ABA, Manejador_BotonAba, NULL);
	    	XIOModule_Connect(piomodule, INTERRUPCION_POTENCIA_U, Manejador_Potencia, NULL);

	    	XIOModule_Enable(piomodule, INTERRUPCION_BOTON_DER);
	    	XIOModule_Enable(piomodule, INTERRUPCION_BOTON_IZQ);
	    	XIOModule_Enable(piomodule, INTERRUPCION_BOTON_ARR);
	    	XIOModule_Enable(piomodule, INTERRUPCION_BOTON_ABA);
	    	XIOModule_Enable(piomodule, INTERRUPCION_POTENCIA_U);

		//- Activamos Interrupciones
			microblaze_enable_interrupts();

		//- Retardo necesario para que el Remote Lab se configure correctamente antes de operar con la E/S del MicroBlaze
			u32 index2;
			for (index2 = 0; index2 < 6000000; index2 ++)
				;
			xil_printf("\t");

		//- Inicializar los sensores la primera vez
			pSen->Prese = AUSENTE;
			pSen->PSigu = AUSENTE;
			pSen->PTime = 0;
			pSen->LuzEx = 75;
			pSen->TemIn = 20;
			pSen->TemEx = 20;
			pSen->Ruido = 20;

		//- Inicialización de actuadores
			pAct->ctLuz = APAGADO;
			pAct->mtVen = APAGADO;
			pAct->mtPer = APAGADO;
			pAct->ptCal = APAGADO;
			pAct->ptAir = APAGADO;
			pAct->stVen = ST_CERRADAS;
			pAct->stPer = ST_CERRADAS;
			pAct->grVen = MIN_APERTURA; // ventanas cerradas
			pAct->grPer = MIN_APERTURA; // persianas bajadas


		//- Inicialización del display 7 segmentos
			SemSensores = 0;
			SemActuadores = 0;

			SemCambios = 1;
			Manejador_Tic_segundos(NULL);

	}

int main()
{

    //- Declaración de variables para sensores y actuadores
		//  R2. Todo el control y almacenamiento de los datos de los sensores se realizará dentro del propio MicroBlaze:
        //      detección de presencia, sensor de luz exterior, sensor de temperatura exterior e interior, y detector de ruido exterior.
        st_Sensores Sen;
		st_Actuadores Act;
		XIOModule iomodule; 	// Hardware de Xilinx

	//- Inicialización de la placa
		Inicializar(&Sen, &Act, &iomodule);

	//- Bucle principal
		while (1)
		{
			SimularSensores(&Sen);
			if (SemSensores) {
				SemSensores ==
			}
	    	SemActuadores = 0;

	    	if (SemTm100ms) {
				SemTm100ms = 0;
				ActualizarPorTiemo(&Sen, &Act);
			}
			if (SemFpgaPot) {
				SemFpgaPot = 0;
				PotCli = (char)XIOModule_DiscreteRead(&iomodule, GPI_POTENCIA);
			}

			if (SemCambios) {
				SemCambios = 0;

				ControlarActuadores(&Sen, &Act);
				ActualizarPantalla(&Sen, &Act);
			}
		}

	//- Finalización (código no alcanzable)
		cleanup_platform();
		return 0;
}

// source ipcore_dir/microblaze_mcs_setup.tcl
// microblaze_mcs_data2mem workspace/hello_world/debug/hello_world.elf
