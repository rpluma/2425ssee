/*
 * Fichero:     practica2.h
 * Autor:       Ricardo Panero
 * Fecha:       Noviembre de 2024
 * Descripción: constantes y estructuras para la práctica 2
 */

#ifndef PRACTICA2_H_
#define PRACTICA2_H_

//- Librerías externas
    #include <stdio.h>
    #include <string.h>
    #include "platform.h"
    #include "xparameters.h"
    #include "xiomodule.h"

//- Constantes simbólicas relacionadas con sensores
    #define AUSENTE 0
    #define PRESENTE 1

    #define MIN_LUZEX 0
    #define MAX_LUZEX 100

    #define MIN_RUIDO 0
    #define MAX_RUIDO 120

    #define MIN_TEMPE  0
    #define MAX_TEMPE  60

    const u8 MASK_SEN = 0x80; // el led más a la izquierda indica modo sensores; el switch permite cambiar de modo
    const u8 MASK_ACT = 0x40; // siguiente led al de los sensores indica modo actuadores


//- Estructura para sensores
    // Por tanto, el objetivo del sistema es crear una vivienda inteligente
    typedef struct {
        //-  monitorizada por los siguientes componentes y sensores:
            u8      Prese;          // 1 detector de presencia en la vivienda (ON – OFF).
            u8      LuzEx;          // 1 sensor de luz exterior (0 – 100%).
            u8      TemIn;          // 2 sensores de temperatura ambiental, uno interior
            u8      TemEx;          // y otro exterior a la vivienda (0 – 60°C).
            u8      Ruido;          // 1 detector de ruido exterior (0 – 120 dB).

        //- Teclado
            u8      modo_sensores;  // estado del primer switch de la FPGA
            u8      valor_display;  // valor que se visualiza en el display de 7 segmentos
            u8      num_activo;     // número de sensor activo (1=Prese, 2=LuzEx, 3=TemIn, 4=TemEx 5=Ruido)
            char    ult_tecla;      // última tecla procesada para visualizar en pantalla
            char    sig_tecla;      // siguiente tecla pulsada que está pendiente de procear

        // Cambios de estado
            u8      Prese_sig;      // siguiente estado de presencia
            u8      TemIn_sig;      // siguiente temperatura interior

    } st_Sensores;


//- Estados de ventanas y persianas
    // R3a También se controlará en el interior del MicroBlaze la acción sobre los motores de las persianas y ventanas
    //     para abrirlas y cerrarlas, generando un cambio progresivo en los mismos.

    typedef enum {  // estado de luces, motores de persinas, motores de ventanas, calefacción y aire acondicionado
        ST_APAGAR,     // luces, aire y calefacción apagadas

        ST_ENCENDER,   // luces encendidas
        ST_CALENTAR,   // encender o mantener la calefacción encendida
        ST_ENFRIAR,    // encender o mantener la calefacción encendida

        ST_CERRADAS,   // ventanas/persianas cerradas, motor parado
        ST_ABRIENDO,   // ventanas/persianas abriéndose, motor encendido
        ST_ABIERTAS,   // ventanas/persianas abiertas, motor parado
        ST_CERRANDO,   // ventanas/persianas cerrándose, motor encendido

        ST_BAJADAS,   // ventanas/persianas cerradas, motor parado
        ST_SUBIENDO,  // ventanas/persianas abriéndose, motor encendido
        ST_SUBIDAS,   // ventanas/persianas abiertas, motor parado
        ST_BAJANDO   // ventanas/persianas cerrándose, motor encendido
    } est_act;

//- Constantes simbólicas relacionadas con actuadores
    static const char *decod_estado[] = {
            "apagado",
            "encendidas", "calentando", "enfriando",
            "cerradas", "abriendo", "abiertas", "cerrando",
            "bajadas", "subiendo", "subidas", "bajando"
    };


    #define OBJ_AIR 23 // Objetivo para el aire acondicionado
    #define OBJ_CAL 18 // Objetivo para la calefacción




//- Estructura para motores de ventanas y persianas
    typedef struct {
        est_act     estad;      // estado actual del actuador
        u8          poten;      // potencia de motores (0=MIN_POTENCIA, 100=MAX_POTENCIA)
    } actuador;

//- Estructura para actuadores
    typedef struct {
        // Y los sistemas que accionaremos serán los siguientes:
            u8 num_activo;  // número de actuador activo (1=luz, 2=ven, 3=per, 4=cal 5=air)
            actuador luz;   // Luces de la casa, apagando o encendiendo las mismas (ON – OFF).
            actuador ven;   // 1 motor para el control de la apertura y cierre de ventanas (0 – 100%)
            actuador per;   // 1 motor para controlar la subida y bajada de persianas (0 – 100%).
            actuador cal;   // 1 control de calefacción, controlando la potencia de acción del mismo (0 – 100%).
            actuador air;   // 1 control de aire acondicionado, también con control de potencia de acción (0 – 100%).
        // FPGA
            char pot_clima;  // Repuesta de FPGA: positiva para encender el aire y negativa para encender la calefacción
            u8   TemIn_ant;  // temperatura interior con la que se calculó la potencia por última vez

    } st_Actuadores;


//- Constantes simbólicas relacionadas con el temporizador
    #define TICS_PANTALLA 2         // se refresca cada después de 2 x 50 ms = 0,1 seg
    #define TICS_AUTOINCREMENTO 200 // se autoincrementa después de  200 x50 ms = 10 seg
    #define TICS_PRESENCIA_5SEG 100 // se cambia de estado  después de 100 x 50ms = 5 seg
    #define GRAD_MIN_APERTURA 0     // mínima apertura la potencia del motor está al 0%
    #define GRAD_MED_APERTURA 100   // cuando la apertura es el 50% el motor está al 100%
    #define GRAD_MAX_APERTURA 200   // mínima apertura la potencia del motor está al 0%

//- Estructura para el temporizador
    typedef struct {
        //- contadores de ticks que se incrementan con cada interrupción
            u16 tics_pant;          // tics desde la última vez que se refrescó la pantalla
            u16 tics_pres;          // tics desde la última vez que se pidió cambiar el sensor de presencia
            u16 tics_auto;          // tics desde que se calculó el autoincremento por última vez
            u16 grad_vent;          // grado de apertura de las ventanas, aumenta/disminuye uno por cada 50ms
            u16 grad_pers;          // grado de subida de las persianas, aumenta/disminuye uno por cada 50ms
        //- semáfores
            u8  sema_fpga;           // semáforo para indicar que la FPGA ha terminado el cálculo de la potencia de climatización
            u8  sema_actu;           // semáforo para indicar que hay que recontrolar los actuadores
            u8  sema_pant;           // semáforo para indicar que hay que refrescar la pantalla
            u8  sema_temp;           // semáforo para indicar que ha saltado la interrupción al menos una vez
        //- contadores de veces que se ejecuta una función
            u16 ejec_pant;           // número de veces que se refresca la pantalla
            u16 ejec_fpga;           // número de veces que se calcula la potencia
            u16 ejec_actu;           // número de veces que se controlan los actuadores

    } st_Temporizador;




//- Interrupciones
    // Constantes para tratar las interrupciones externas y asociarlas a sus correspondientes manejadores.
    // La primera está situada siempre en XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR,
    // y las siguientes en posiciones consecutivas.
    static const u8 INTERRUPCION_BOTON_DER = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR;
    static const u8 INTERRUPCION_BOTON_IZQ = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR+1;
    static const u8 INTERRUPCION_BOTON_ARR = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR+2;
    static const u8 INTERRUPCION_BOTON_ABA = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR+3;
    static const u8 INTERRUPCION_POTENCIA_U = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR+4;

//- Constantes relacionadas con el micro
    #define GPI_POTENCIA 1
    #define GPI_SWITCHES 2
    #define GPO_TEMPERATURAS 1
    #define GPO_LEDS 2
    #define GPO_BCDS 3

//- Teclas asociadas a los botones de la FPGA
    #define TECLA_ARR '8'
    #define TECLA_ABA '2'
    #define TECLA_IZQ '4'
    #define TECLA_DER '6'

//- Máscaras para pasar datos a la FPGA
    const u32 MASK_0_CAL =           (OBJ_CAL << 8);
    const u32 MASK_1_CAL = (1<<16) | (OBJ_CAL << 8);

    const u32 MASK_0_AIR =           (OBJ_AIR << 8);
    const u32 MASK_1_AIR = (1<<16) | (OBJ_AIR << 8);

#endif /* PRACTICA2_H_ */
