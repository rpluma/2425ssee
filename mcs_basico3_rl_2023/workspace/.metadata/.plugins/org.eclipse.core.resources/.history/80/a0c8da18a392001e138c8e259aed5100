/*
 * helloworld.c: simple test application
 */

#include <stdio.h>
#include "platform.h"
#include "xparameters.h"
#include "xiomodule.h"


// Constantes para tratar las interrupciones externas y asociarlas a sus correspondientes manejadores.
// La primera está situada siempre en XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR,
// y las siguientes en posiciones consecutivas.
static const u8 IDENTIFICADOR_INTC0_EXT = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR;
static const u8 IDENTIFICADOR_INTC1_EXT = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR+1;
static const u8 IDENTIFICADOR_INTC2_EXT = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR+2;
static const u8 IDENTIFICADOR_INTC3_EXT = XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR+3;

// Dirección del bus de donde leeremos y escribiremos con el IOBus
// ATENCIÓN: SÓLO SE PUEDE LLEGAR A DECODIFICAR HASTA 30 BITS, NO LOS 32 DEL BUS.
static const u32 DIRECCION0 = 0x00000004;


//  Variable para inicializar la E/S. Se pone global
//  para que puedan usarla los manejadores de interrupciones

XIOModule iomodule;

// Variable para albergar los datos leídos del GPI (switches)
u8 data_sw = 0x00;

// Variable para albergar los datos a escribir en el GPO 1 (leds)
u8 data_gpo1 = 0x00;


void Manejador_Int_Temporizador1 (void* ref)
{
	// Manejador de interrupciones para el FIT1, programado a 1 segundo

	// Escribe los 4 bits más significativos de 'data_gpo1' en los LEDs de salida, invirtiendo su valor
	if ((data_gpo1 & 0xF0) == 0x00) // Sólo comprobamos los 4 bits más significativos
		data_gpo1 = data_gpo1 | 0xF0; // Ponemos a '1' los 4 bits más significativos haciendo una "OR"
	else
		data_gpo1 = data_gpo1 & 0x0F; // Ponemos a '0' los 4 bits más significativos haciendo una "AND"
	XIOModule_DiscreteWrite(&iomodule, 1, data_gpo1);
}


//Variables para los manejadores de interrupciones externas:

// Contador de 0 a 9
int contador = 0;
// Variable para el display LCD, en BCD
u8 valor_bcd = 0;

void Manejador_INTC0 (void* ref)
{
	// Manejador de interrupciones para INTC0 (Interrupción Externa 0), conectada a un botón externo

	// Incrementa el valor de "contador" en uno siempre que sea menor que 9 (si no lo es lo pone a cero),
	// y escribe en el display de 7 segmentos usando GPO2
	contador++;
	if (contador > 9)
		{
		 contador = 0;
		}
	valor_bcd = contador;
	XIOModule_DiscreteWrite(&iomodule, 2, valor_bcd);
}

void Manejador_INTC1 (void* ref)
{
	// Manejador de interrupciones para INTC1 (Interrupción Externa 1), conectada a un botón externo

	// Decrementa el valor de "contador" en uno siempre que sea mayor que 0 (si no lo es lo pone a 9),
	// y escribe en el display de 7 segmentos usando GPO2
	contador--;
	if (contador < 0)
		{
		 contador = 9;
		}
	valor_bcd = contador;
	XIOModule_DiscreteWrite(&iomodule, 2, valor_bcd);
}

void Manejador_INTC2 (void* ref)
{
	// Manejador de interrupciones para INTC2 (Interrupción Externa 2), conectada a un botón externo

	// Leemos del IOBus el valor que hay en los 4 switches menos significativos de entrada a través de la FPGA
	// cuando se pulse el botón adecuado (arriba), y escribimos el dato en los 4 bits menos significativos del GPO1
	// (que irá a un 7 segmentos)
	// Leemos del IoBus, en la DIRECCION0, y ponemos el dato leído en 'data_sw'
	data_sw = XIOModule_IoReadByte(&iomodule, DIRECCION0);
	// Escribimos el dato de los switches en los 4 bits menos significativos del GPO 1, respetando el valor del resto de bits
	// Dejamos en 'data_sw' los valores de los 4 bits menos significativos, poniendo a cero el resto mediante una AND
	data_sw = data_sw & 0x0F;
	// Dejamos en 'data_gpo1' los valores de los 4 bits más significativos solamente, poniendo a cero el resto mediante una AND
	data_gpo1 = data_gpo1 & 0xF0;
	// Calculamos el nuevo valor de salida de 'data_gpo1' haciendo la OR de ella misma con data_sw;
	data_gpo1 = data_gpo1 | data_sw;
	XIOModule_DiscreteWrite(&iomodule, 1, data_gpo1);
}

void Manejador_INTC3 (void* ref)
{
	// Manejador de interrupciones para INTC3 (Interrupción Externa 3), conectada a un botón externo

	// Escribe en el IOBus el valor que hay en los switches de entrada (los 4 bits menos significativos)
	// cuando se pulse el botón adecuado (abajo).
	// Lee estado de switches en 'data_sw'
	data_sw = XIOModule_DiscreteRead(&iomodule, 1);
	// Escribimos en el IOBus, en la DIRECCION0, el dato leído de los switches 'data_sw'
	XIOModule_IoWriteByte(&iomodule, DIRECCION0, data_sw);
}




int main()
{
	// Inicializa el micro
	init_platform();

	// Define diversas variables que usaremos para la E/S
	u32 data;
	u8 index;

	// Define la variable para el buffer de entrada
	u8 rx_buf[5];

	// Inicializa el módulo de GPI, GPO y la UART para obtener la dirección base:
	data = XIOModule_Initialize(&iomodule, XPAR_IOMODULE_0_DEVICE_ID);
	data = XIOModule_Start(&iomodule);

	// Iniciamos el manejador de interrupciones
	microblaze_register_handler(XIOModule_DeviceInterruptHandler, XPAR_IOMODULE_0_DEVICE_ID);

	// Registramos el manejador de interrupciones para el FIT1 "Manejador_Int_Temporizador1"
	XIOModule_Connect(&iomodule, XIN_IOMODULE_FIT_1_INTERRUPT_INTR, Manejador_Int_Temporizador1, NULL);

	// Activamos la interrupción para FIT1
	XIOModule_Enable(&iomodule, XIN_IOMODULE_FIT_1_INTERRUPT_INTR);

	// Registramos el manejador de interrupciones para INTC0 (Interrupción externa 0) "Manejador_INTC0"
	XIOModule_Connect(&iomodule, IDENTIFICADOR_INTC0_EXT, Manejador_INTC0, NULL);

	// Activamos la interrupción para INTC 0
	XIOModule_Enable(&iomodule, IDENTIFICADOR_INTC0_EXT);

	// Registramos el manejador de interrupciones para INTC 1 (Interrupción externa 1) "Manejador_INTC1"
	XIOModule_Connect(&iomodule, IDENTIFICADOR_INTC1_EXT, Manejador_INTC1, NULL);

	// Activamos la interrupción para INTC 1
	XIOModule_Enable(&iomodule, IDENTIFICADOR_INTC1_EXT);

	// Registramos el manejador de interrupciones para INTC 2 (Interrupción externa 2) "Manejador_INTC2"
	XIOModule_Connect(&iomodule, IDENTIFICADOR_INTC2_EXT, Manejador_INTC2, NULL);

	// Activamos la interrupción para INTC 2
	XIOModule_Enable(&iomodule, IDENTIFICADOR_INTC2_EXT);

	// Registramos el manejador de interrupciones para INTC 3 (Interrupción externa 3) "Manejador_INTC3"
	XIOModule_Connect(&iomodule, IDENTIFICADOR_INTC3_EXT, Manejador_INTC3, NULL);

	// Activamos la interrupción para INTC 3
	XIOModule_Enable(&iomodule, IDENTIFICADOR_INTC3_EXT);

	// Activamos Interrupciones
	microblaze_enable_interrupts();

	// Inicializamos el display de 7 segmentos con el 0
	valor_bcd = 0;
	XIOModule_DiscreteWrite(&iomodule, 2, valor_bcd);

	// Envía por la UART el mensaje indicado
	xil_printf("\n\r\n\rLectura de Switches - Escritura de LEDs - Usando Interrupciones\n\r\n\r");

	// Se llama a la función CfgInitialize para inicializar las funciones de envío y recepción
	// desde la UART. Nótese que los argumentos que nos indica la configuración y la dirección
	// efectiva no se usarán posteriormente
	// int XIOModule_CfgInitialize(XIOModule *InstancePtr, XIOModule_Config *Config, u32 EffectiveAddr);
	data = XIOModule_CfgInitialize(&iomodule, NULL, 1);

	xil_printf("\n\rIntroduzca un texto, el Microcontrolador lo convertirá en mayúsculas:\n\r");





	// Bucle en el que se espera a recibir un carácter por la UART, y lo escribe otra vez en la misma
	// pero convertido a mayúsculas (si procede), haciendo un "eco" de lo recibido, por tanto.
	// Mientras, cada segundo se generará una interrupción en el temporizador FIT1 que detendrá a dicho bucle
	// y saltará al manejador, y si se pulsa el botón adecuado se generará una interrupción en INTC también
	while (1)
	{
		// Leemos un carácter de la UART
		data = XIOModule_Recv(&iomodule, rx_buf, 1);

		// Si realmente hemos recibido un byte, comprobamos si es una letra minúscula
		// y la pasamos a mayúsculas; si no es una letra minúscula la enviamos tal y como está.
		if (data !=0)
		{
			// Hemos recibido un dato
			if ((rx_buf[0] >= 97) & (rx_buf[0] <= 122))
			{
				// Es una letra minúscula, la convertimos a mayúscula
				rx_buf[0] -=32;
			}

			// Enviamos el dato por la UART. Cuando 'index' valga > 0 quiere decir
			// que hemos enviado el dato correctamente.
			index = 0;
			while (index < 1)
			{
				data = XIOModule_Send(&iomodule, rx_buf, 1);
				index += data;
			}

			// Si el dato enviado es un retorno de carro ("ENTER") entonces enviamos
			// un salto de línea adicionalmente.
			if (rx_buf[0]==13)
			{
				index = 0;
				rx_buf[0] = 10;
				while (index < 1)
				{
					data = XIOModule_Send(&iomodule, rx_buf, 1);
					index += data;
				}
			}
		}
	}

	cleanup_platform();
	return 0;
}

// source ipcore_dir/microblaze_mcs_setup.tcl
// microblaze_mcs_data2mem workspace/hello_world/debug/hello_world.elf
